import Foundation
import Combine

class OptionsChainAnalyzer {
    private let calculator = OptionsGreeksCalculator()
    private var cancellables = Set<AnyCancellable>()
    
    // MARK: - Public Methods
    
    /// Analyze an options chain and return comprehensive metrics
    func analyzeOptionsChain(chain: NIFTYOptionsChain, underlyingPrice: Double) -> OptionsChainAnalysis {
        // Calculate key metrics
        let metrics = chain.calculateMetrics()
        let greeksExposure = calculateGreeksExposure(chain: chain)
        let volatilityProfile = analyzeImpliedVolatility(chain: chain)
        let oiConcentration = analyzeOpenInterestConcentration(chain: chain)
        
        // Analyze market sentiment
        let sentiment = analyzeMarketSentiment(chain: chain, underlyingPrice: underlyingPrice)
        
        // Return comprehensive analysis
        return OptionsChainAnalysis(
            metrics: metrics,
            greeksExposure: greeksExposure,
            volatilityProfile: volatilityProfile,
            sentiment: sentiment,
            oiConcentration: oiConcentration
        )
    }
    
    /// Analyze an options chain and return comprehensive metrics
    func analyzeOptionsChain(chain: NIFTYOptionsChain) -> OptionsChainAnalysis {
        return analyzeOptionsChain(chain: chain, underlyingPrice: chain.underlyingPrice)
    }
    
    /// Identify potential trading opportunities based on options chain analysis
    func identifyTradingOpportunities(chain: NIFTYOptionsChain) -> [TradingOpportunity] {
        var opportunities: [TradingOpportunity] = []
        
        // Get the analysis
        let analysis = analyzeOptionsChain(chain: chain)
        
        // Check for high IV percentile opportunities
        if analysis.volatilityProfile.ivPercentile > 0.8 {
            opportunities.append(TradingOpportunity(
                type: .highIV,
                description: "High implied volatility environment (IV percentile: \(Int(analysis.volatilityProfile.ivPercentile * 100))%)",
                suggestedStrategies: ["Short Straddle", "Iron Condor", "Credit Spread"],
                confidence: 0.8
            ))
        }
        
        // Check for low IV percentile opportunities
        if analysis.volatilityProfile.ivPercentile < 0.2 {
            opportunities.append(TradingOpportunity(
                type: .lowIV,
                description: "Low implied volatility environment (IV percentile: \(Int(analysis.volatilityProfile.ivPercentile * 100))%)",
                suggestedStrategies: ["Long Straddle", "Long Strangle", "Calendar Spread"],
                confidence: 0.75
            ))
        }
        
        // Check for skew-based opportunities
        if analysis.volatilityProfile.skew > 0.15 {
            opportunities.append(TradingOpportunity(
                type: .skewOpportunity,
                description: "Significant volatility skew detected (\(String(format: "%.2f", analysis.volatilityProfile.skew)))",
                suggestedStrategies: ["Ratio Spread", "Risk Reversal"],
                confidence: 0.7
            ))
        }
        
        // Check for unusual open interest
        let unusualStrikes = analysis.oiConcentration.unusualStrikes
        if !unusualStrikes.isEmpty {
            let strikesList = unusualStrikes.map { String($0) }.joined(separator: ", ")
            opportunities.append(TradingOpportunity(
                type: .unusualActivity,
                description: "Unusual open interest detected at strikes: \(strikesList)",
                suggestedStrategies: ["Directional Trade", "Butterfly Spread"],
                confidence: 0.65
            ))
        }
        
        return opportunities
    }
    
    // MARK: - Private Methods
    
    /// Calculate the exposure to different option Greeks
    private func calculateGreeksExposure(chain: NIFTYOptionsChain) -> GreeksExposure {
        var netDelta: Double = 0
        var netGamma: Double = 0
        var netTheta: Double = 0
        var netVega: Double = 0
        
        // Calculate net exposure for each Greek
        for option in chain.options {
            let multiplier = option.openInterest
            
            netDelta += option.delta * Double(multiplier)
            netGamma += option.gamma * Double(multiplier)
            netTheta += option.theta * Double(multiplier)
            netVega += option.vega * Double(multiplier)
        }
        
        return GreeksExposure(
            netDelta: netDelta,
            netGamma: netGamma,
            netTheta: netTheta,
            netVega: netVega
        )
    }
    
    /// Analyze the implied volatility profile of the options chain
    private func analyzeImpliedVolatility(chain: NIFTYOptionsChain) -> VolatilityProfile {
        // Calculate average IV
        let allIVs = chain.options.map { $0.impliedVolatility }
        let avgIV = allIVs.reduce(0, +) / Double(allIVs.count)
        
        // Calculate IV skew (difference between put and call IVs)
        let putIVs = chain.options.filter { $0.optionType == .put }.map { $0.impliedVolatility }
        let callIVs = chain.options.filter { $0.optionType == .call }.map { $0.impliedVolatility }
        
        let avgPutIV = putIVs.reduce(0, +) / Double(putIVs.count)
        let avgCallIV = callIVs.reduce(0, +) / Double(callIVs.count)
        
        let skew = avgPutIV - avgCallIV
        
        // Mock IV percentile calculation (in a real app, would compare to historical data)
        let ivPercentile = min(max(avgIV / 0.4, 0), 1) // Assuming 40% IV is the max reference
        
        return VolatilityProfile(
            averageIV: avgIV,
            skew: skew,
            ivPercentile: ivPercentile,
            termStructure: [:] // Would be populated with actual term structure in a real app
        )
    }
    
    /// Analyze open interest concentration
    private func analyzeOpenInterestConcentration(chain: NIFTYOptionsChain) -> OIConcentration {
        // Find strikes with unusually high open interest
        let avgOI = chain.options.map { $0.openInterest }.reduce(0, +) / chain.options.count
        let threshold = Double(avgOI) * 2.0 // Threshold for "unusual" OI
        
        let unusualStrikes = chain.options
            .filter { Double($0.openInterest) > threshold }
            .map { $0.strikePrice }
        
        // Calculate put/call OI ratio at each strike
        var strikeOIRatios: [Double: Double] = [:]
        
        let strikeGroups = Dictionary(grouping: chain.options) { $0.strikePrice }
        for (strike, options) in strikeGroups {
            let puts = options.filter { $0.optionType == .put }
            let calls = options.filter { $0.optionType == .call }
            
            let putOI = puts.map { $0.openInterest }.reduce(0, +)
            let callOI = calls.map { $0.openInterest }.reduce(0, +)
            
            if callOI > 0 {
                strikeOIRatios[strike] = Double(putOI) / Double(callOI)
            }
        }
        
        return OIConcentration(
            unusualStrikes: unusualStrikes,
            strikeOIRatios: strikeOIRatios
        )
    }
    
    /// Analyze market sentiment from options data
    private func analyzeMarketSentiment(chain: NIFTYOptionsChain, underlyingPrice: Double) -> MarketSentimentAnalysis {
        _ = chain.getATMStrike()
        
        // Calculate put/call ratio
        let pcr = chain.calculateMetrics().pcr
        
        // Calculate OI put/call ratio
        let oiPcr = chain.calculateMetrics().oiPcr
        
        // Calculate volatility skew
        let volatilityProfile = analyzeImpliedVolatility(chain: chain)
        let skew = volatilityProfile.skew
        
        // Calculate net gamma exposure
        let greeksExp = calculateGreeksExposure(chain: chain)
        
        // Determine sentiment based on multiple factors
        let sentimentScore = calculateSentimentScore(pcr: pcr, oiPcr: oiPcr, skew: skew, gamma: greeksExp.netGamma)
        
        return MarketSentimentAnalysis(
            putCallRatio: pcr,
            oiPutCallRatio: oiPcr,
            volatilitySkew: skew,
            sentimentScore: sentimentScore,
            marketSentiment: interpretSentiment(sentimentScore),
            keywords: nil,
            sources: nil
        )
    }
    
    /// Calculate a sentiment score based on options metrics
    private func calculateSentimentScore(pcr: Double, oiPcr: Double, skew: Double, gamma: Double) -> Double {
        // Normalize each factor to a -1 to 1 scale
        let pcrFactor = normalizePCR(pcr)
        let oiPcrFactor = normalizePCR(oiPcr)
        let skewFactor = normalizeSkew(skew)
        let gammaFactor = normalizeGamma(gamma)
        
        // Weight the factors (these weights would be optimized in a real system)
        let pcrWeight = 0.3
        let oiPcrWeight = 0.3
        let skewWeight = 0.25
        let gammaWeight = 0.15
        
        // Calculate weighted average
        let sentimentScore = (pcrFactor * pcrWeight) +
                            (oiPcrFactor * oiPcrWeight) +
                            (skewFactor * skewWeight) +
                            (gammaFactor * gammaWeight)
        
        return sentimentScore
    }
    
    /// Normalize PCR to a -1 to 1 scale
    private func normalizePCR(_ pcr: Double) -> Double {
        // PCR > 1 indicates bearishness, < 1 indicates bullishness
        if pcr > 1.0 {
            return min((pcr - 1.0) * -1.0, -0.1) // Negative score for bearish
        } else {
            return min((1.0 - pcr) * 1.0, 1.0) // Positive score for bullish
        }
    }
    
    /// Normalize skew to a -1 to 1 scale
    private func normalizeSkew(_ skew: Double) -> Double {
        // Positive skew (puts more expensive than calls) indicates bearishness
        return min(max(skew * -3.0, -1.0), 1.0)
    }
    
    /// Normalize gamma to a -1 to 1 scale
    private func normalizeGamma(_ gamma: Double) -> Double {
        // This is a simplified approach; in reality, the interpretation of gamma
        // would depend on market context and positioning
        return min(max(gamma / 1000000.0, -1.0), 1.0)
    }
    
    /// Interpret sentiment score into a market sentiment category
    private func interpretSentiment(_ score: Double) -> String {
        if score > 0.5 {
            return "Bullish"
        } else if score > 0.2 {
            return "Moderately Bullish"
        } else if score > -0.2 {
            return "Neutral"
        } else if score > -0.5 {
            return "Moderately Bearish"
        } else {
            return "Bearish"
        }
    }
}

// MARK: - Supporting Types

struct MarketSentimentAnalysis {
    let putCallRatio: Double?
    let oiPutCallRatio: Double?
    let volatilitySkew: Double?
    let sentimentScore: Double
    let marketSentiment: String
    let keywords: [String]?
    let sources: [String]?
}

struct OptionsChainAnalysis {
    let metrics: OptionsChainMetrics
    let greeksExposure: GreeksExposure
    let volatilityProfile: VolatilityProfile
    let sentiment: MarketSentimentAnalysis
    let oiConcentration: OIConcentration
}

struct GreeksExposure {
    let netDelta: Double
    let netGamma: Double
    let netTheta: Double
    let netVega: Double
}

struct VolatilityProfile {
    let averageIV: Double
    let skew: Double
    let ivPercentile: Double
    let termStructure: [String: Double]
}

struct OIConcentration {
    let unusualStrikes: [Double]
    let strikeOIRatios: [Double: Double]
}

struct TradingOpportunity {
    enum OpportunityType {
        case highIV
        case lowIV
        case skewOpportunity
        case unusualActivity
        case technicalPattern
    }
    
    let type: OpportunityType
    let description: String
    let suggestedStrategies: [String]
    let confidence: Double
}
